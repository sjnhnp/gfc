import { stringify } from 'yaml'

import {
  AdvancedConfigDefaults,
  DnsConfigDefaults,
  GeneralConfigDefaults,
  TunConfigDefaults,
  MixinConfigDefaults,
  ScriptConfigDefaults,
  BuiltInOutbound,
} from '@/constant'
import { RulesetBehavior, RulesetFormat, RuleType } from '@/enums/kernel'
import { deepAssign, sampleID } from '@/utils'

import type { ProfileType } from '@/stores'

export const restoreProfile = (
  config: Record<string, any>,
  subID: string,
  NameIdMap: Record<string, string>,
  IdNameMap: Record<string, string>,
) => {
  const profile: ProfileType = {
    // The same ID indicates that this profile was generated by this subscription
    id: subID,
    name: subID,
    generalConfig: GeneralConfigDefaults(),
    advancedConfig: AdvancedConfigDefaults(),
    dnsConfig: Object.assign(DnsConfigDefaults(), {
      nameserver: [],
      'nameserver-policy': {},
    }),
    tunConfig: TunConfigDefaults(),
    proxyGroupsConfig: [],
    rulesConfig: [
      {
        id: RuleType.InsertionPoint,
        type: RuleType.InsertionPoint,
        enable: true,
        payload: '',
        proxy: '',
        'no-resolve': false,
        'ruleset-name': '',
        'ruleset-type': 'file',
        'ruleset-behavior': RulesetBehavior.Domain,
        'ruleset-format': RulesetFormat.Mrs,
        'ruleset-proxy': '',
        'ruleset-interval': 0,
      },
    ],
    mixinConfig: MixinConfigDefaults(),
    scriptConfig: ScriptConfigDefaults(),
    subRulesConfig: {},
  }

  const GroupNameIdMap: Record<string, string> = {}
  const GroupIdNameMap: Record<string, string> = {}

  config['proxy-groups'] = config['proxy-groups'] || []
  config['rule-providers'] = config['rule-providers'] || {}

  config['proxy-groups'].forEach((group: any) => {
    const id = sampleID()
    GroupNameIdMap[group.name] = id
    GroupIdNameMap[id] = group.name
  })

  function isBuiltIn(proxy: string) {
    return BuiltInOutbound.includes(proxy)
  }

  config['proxy-groups'].forEach((group: any) => {
    const _group: ProfileType['proxyGroupsConfig'][number] = {
      id: GroupNameIdMap[group.name]!,
      name: group.name,
      type: group.type,
      proxies: (group.proxies || [])
        .map((proxy: string) => ({
          id: GroupNameIdMap[proxy] || NameIdMap[proxy] || proxy,
          type: GroupNameIdMap[proxy] || isBuiltIn(proxy) ? 'Built-In' : subID,
          name: GroupNameIdMap[proxy]
            ? GroupIdNameMap[GroupNameIdMap[proxy]]
            : IdNameMap[NameIdMap[proxy]!] || (isBuiltIn(proxy) && proxy),
        }))
        // The absence of a 'name' attribute indicates that this proxy has been excluded after processing by filters or plugins.
        .filter((v: any) => v.name),
      url: group.url ?? 'https://www.gstatic.com/generate_204',
      interval: group.interval ?? 300,
      strategy: group.strategy ?? 'consistent-hashing',
      use: (group.use || []).map((use: string) => {
        return GroupNameIdMap[use] || use
      }),
      tolerance: group.tolerance ?? 150,
      lazy: group.lazy ?? true,
      'disable-udp': group['disable-udp'] ?? false,
      filter: group.filter ?? '',
      'exclude-filter': group['exclude-filter'] ?? '',
      hidden: group.hidden ?? false,
      icon: group.icon ?? '',
    }

    profile.proxyGroupsConfig.push(_group)
  })

  function getRuleProxy(type: string) {
    return BuiltInOutbound.includes(type.toUpperCase())
      ? type.toUpperCase()
      : GroupNameIdMap[type] || IdNameMap[NameIdMap[type]!]
  }

  let isGeoModeEnabled = false

  Object.entries(config).forEach(([field, value]) => {
    if (Object.hasOwnProperty.call(profile.generalConfig, field)) {
      ; (profile.generalConfig as any)[field] = value
    } else if (Object.hasOwnProperty.call(profile.advancedConfig, field)) {
      ; (profile.advancedConfig as any)[field] = value
    } else if (field === 'dns') {
      if (value['fake-ip-filter']) {
        value['fake-ip-filter'] = value['fake-ip-filter'].flatMap((v: string) =>
          v.startsWith('rule-set:')
            ? v
              .substring(9)
              .split(',')
              .map((x) => `rule-set:${x}`)
            : [v],
        )
      }
      profile.dnsConfig = deepAssign(profile.dnsConfig, value)
    } else if (field === 'tun') {
      profile.tunConfig = deepAssign(profile.tunConfig, value)
    } else if (field === 'hosts') {
      Object.entries<string | string[]>(value).forEach(([key, value]) => {
        if (Array.isArray(value)) {
          profile.dnsConfig.hosts[key] = value.join(',')
        } else {
          profile.dnsConfig.hosts[key] = value
        }
      })
    } else if (field === 'rules') {
      config[field].forEach((rule: string, index: number) => {
        let qs = rule
        let noResolve = false

        if (qs.toLowerCase().endsWith('no-resolve')) {
          noResolve = true
          qs = qs.substring(0, qs.lastIndexOf(','))
        }

        const lastComma = qs.lastIndexOf(',')
        const payloadAndType = qs.substring(0, lastComma)
        const proxy = qs.substring(lastComma + 1)

        const parts = payloadAndType.split(',')
        let type = parts[0]
        let payload = parts.slice(1).join(',')

        // Handle logical/complex rules (AND, OR, NOT, etc)
        const upperType = type.toUpperCase()
        if (
          ['AND', 'OR', 'NOT', 'SUB-RULE'].includes(upperType) ||
          payloadAndType.includes('((')
        ) {
          type = RuleType.Logic
          payload = payloadAndType
        }

        // SUB-RULE type doesn't use proxy parameter
        // Format: SUB-RULE,(logic_condition),sub_rule_name
        const isSubRule = upperType === 'SUB-RULE'

        let _proxy: string | undefined
        if (!isSubRule) {
          // For all non-SUB-RULE rules, the proxy/policy is in the 'proxy' variable
          _proxy = getRuleProxy(proxy)
        } else {
          // For SUB-RULE, the last part is the sub-rule name
          // We'll use the proxy field to store the sub-rule name
          _proxy = proxy // e.g., "QUIC_CHECK"
        }

        // Skip invalid rules：proxy missing (except for SUB-RULE which doesn't need proxy)
        if (!_proxy && !isSubRule) {
          return
        }

        if (type === RuleType.RuleSet) {
          const provider = config['rule-providers'][payload]
          // Skip invalid rules：rule-provider missing
          if (!provider) {
            return
          }
          profile.rulesConfig.push({
            id: index.toString(),
            type: type,
            enable: true,
            payload: provider.type == 'inline' ? stringify(provider.payload) : provider.url,
            proxy: _proxy,
            'no-resolve': !!noResolve,
            'ruleset-behavior': provider.behavior,
            'ruleset-format': provider.format || RulesetFormat.Yaml,
            'ruleset-type': provider.type || 'http',
            'ruleset-name': payload,
            'ruleset-proxy': 'DIRECT',
            'ruleset-interval': parseInt(provider.interval) || 0,
          })
          return
        }

        // if (type === RuleType.Geoip || type === RuleType.Geosite) {
        //   isGeoModeEnabled = true
        // }

        profile.rulesConfig.push({
          id: index.toString(),
          type: type as RuleType,
          enable: true,
          payload: type === 'MATCH' ? '' : payload,
          proxy: _proxy,
          'no-resolve': !!noResolve,
          'ruleset-behavior': RulesetBehavior.Domain,
          'ruleset-format': RulesetFormat.Mrs,
          'ruleset-type': 'http',
          'ruleset-name': '',
          'ruleset-proxy': '',
          'ruleset-interval': 0,
        })
      })
    } else if (field === 'sub-rules') {
      profile.subRulesConfig = value
    }
  })

  // profile.advancedConfig['geodata-mode'] = isGeoModeEnabled

  // Extract rule-set references from fake-ip-filter and nameserver-policy
  // These rule-sets need to be included in rule-providers even if not used in rules
  // Store them separately in dnsRuleProviders so they don't pollute the rules GUI
  const ruleProviders = config['rule-providers'] || {}
  const usedRulesets = new Set(
    profile.rulesConfig
      .filter(r => r.type === RuleType.RuleSet)
      .map(r => r['ruleset-name'])
  )

  // Extract rule-set names from fake-ip-filter
  const fakeIpFilter = profile.dnsConfig['fake-ip-filter'] || []
  const fakeIpRulesets = fakeIpFilter.flatMap((v: string) =>
    v.startsWith('rule-set:')
      ? v.substring(9).split(',').map(x => x.trim())
      : []
  )

  // Extract rule-set names from nameserver-policy
  const nameserverPolicy = profile.dnsConfig['nameserver-policy'] || {}
  const nameserverPolicyRulesets = Object.keys(nameserverPolicy).flatMap((key) =>
    key.startsWith('rule-set:')
      ? key.substring(9).split(',').map(x => x.trim())
      : []
  )

  // Combine and dedupe
  const dnsReferenceRulesets = Array.from(new Set([...fakeIpRulesets, ...nameserverPolicyRulesets]))

  // Store DNS-only rule providers separately (not in rulesConfig)
  const dnsRuleProviders: Record<string, any> = {}
  dnsReferenceRulesets.forEach((rulesetName) => {
    if (usedRulesets.has(rulesetName)) {
      return // Already in rulesConfig, no need to store separately
    }

    const provider = ruleProviders[rulesetName]
    if (!provider) {
      return // Provider not defined
    }

    // Store the provider definition for DNS use
    dnsRuleProviders[rulesetName] = {
      type: provider.type || 'http',
      behavior: provider.behavior,
      format: provider.format,
      url: provider.url,
      path: provider.path,
      interval: parseInt(provider.interval) || 86400,
      payload: provider.payload,
    }
  })

  if (Object.keys(dnsRuleProviders).length > 0) {
    profile.dnsRuleProviders = dnsRuleProviders
  }

  return profile
}
