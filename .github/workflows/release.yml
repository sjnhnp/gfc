name: Build GUI.for.Clash

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g. v1.17.1). Leave empty to auto-increment patch version.'
        required: false
        default: ''

permissions:
  contents: write

jobs:
  Build-Frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: pnpm/action-setup@v4
        with:
          version: latest
      - uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "pnpm"
          cache-dependency-path: frontend/pnpm-lock.yaml
      - name: Get Version
        id: get_version
        run: |
          if [ "${{ github.event_name }}" == "push" ]; then
            echo "VERSION=${{ github.ref_name }}" >> $GITHUB_ENV
          else
            INPUT_VER="${{ github.event.inputs.version }}"
            if [ ! -z "$INPUT_VER" ]; then
              echo "VERSION=$INPUT_VER" >> $GITHUB_ENV
            else
              # Get the highest version tag by sorting all tags
              LATEST_TAG=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*" | sort -V | tail -n 1)
              if [ -z "$LATEST_TAG" ]; then
                LATEST_TAG="v0.0.0"
              fi
              echo "Found latest tag: $LATEST_TAG"
              VERSION_NO_V=${LATEST_TAG#v}
              IFS='.' read -r -a PARTS <<< "$VERSION_NO_V"
              MAJOR=${PARTS[0]}
              MINOR=${PARTS[1]}
              PATCH=${PARTS[2]}
              # Increment and check if tag exists
              while true; do
                NEW_PATCH=$((PATCH + 1))
                NEW_TAG="v$MAJOR.$MINOR.$NEW_PATCH"
                if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
                  echo "Tag $NEW_TAG already exists, trying next..."
                  PATCH=$NEW_PATCH
                else
                  break
                fi
              done
              echo "VERSION=$NEW_TAG" >> $GITHUB_ENV
            fi
          fi

      - run: |
          cd frontend
          pnpm install --frozen-lockfile
          VITE_APP_VERSION=${{ env.VERSION }} pnpm build-only
      - uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

  Build-Windows:
    needs: Build-Frontend
    runs-on: windows-latest
    env:
      APP_NAME: GUI.for.Clash
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for git describe to work
      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          check-latest: true
      - run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
      - uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

      - name: Get Version
        id: get_version
        shell: pwsh
        run: |
          if ("${{ github.event_name }}" -eq "push") {
            # Tag push: use the tag name
            "VERSION=${{ github.ref_name }}" | Out-File -FilePath $env:GITHUB_ENV -Append
          } else {
            # Manual trigger: use input or auto-increment
            $inputVer = "${{ github.event.inputs.version }}"
            if ($inputVer) {
              "VERSION=$inputVer" | Out-File -FilePath $env:GITHUB_ENV -Append
            } else {
              # Get the highest version tag by sorting all tags
              $allTags = git tag -l "v*.*.*" | Where-Object { $_ -match '^v\d+\.\d+\.\d+$' }
              if ($allTags) {
                $latestTag = $allTags | Sort-Object { [version]($_ -replace '^v', '') } | Select-Object -Last 1
              } else {
                $latestTag = "v0.0.0"
              }
              Write-Host "Found latest tag: $latestTag"
              $versionParts = $latestTag.Substring(1) -split '\.'
              $major = $versionParts[0]
              $minor = $versionParts[1]
              $patch = [int]$versionParts[2]
              # Increment and check if tag exists
              do {
                $patch++
                $newTag = "v$major.$minor.$patch"
                $tagExists = git rev-parse $newTag 2>$null
                if ($tagExists) {
                  Write-Host "Tag $newTag already exists, trying next..."
                }
              } while ($tagExists)
              Write-Host "Auto-incremented version to $newTag"
              "VERSION=$newTag" | Out-File -FilePath $env:GITHUB_ENV -Append
            }
          }

      - name: Build & Pack Windows
        shell: pwsh
        run: |
          function Build-And-Pack {
            param([string]$arch)
            $env:GOOS="windows"
            $env:GOARCH=$arch

            $ldflags = "-X 'guiforcores/bridge.Version=$env:VERSION'"
            Write-Host "==> Building Windows $arch with version $env:VERSION..."
            ~/go/bin/wails build -m -s -trimpath -skipbindings -devtools -tags webkit2_41 -ldflags $ldflags -o "$env:APP_NAME.exe"

            cd build/bin
            $zipName = "$env:APP_NAME-windows-$arch.zip"
            Compress-Archive -Path "$env:APP_NAME.exe" -DestinationPath $zipName -Force
            cd ../..
          }

          $arches = @("amd64","arm64","386")
          foreach ($arch in $arches) { Build-And-Pack $arch }

      - uses: actions/upload-artifact@v4
        with:
          name: windows-builds
          path: build/bin/*.zip

  Build-macOS:
    needs: Build-Frontend
    runs-on: macos-latest
    env:
      APP_NAME: GUI.for.Clash
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for git describe to work
      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          check-latest: true
      - run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
      - uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist
      - run: |
          go mod vendor
          sed -i "" "s/\[NSApp setActivationPolicy:NSApplicationActivationPolicyRegular\]/[NSApp setActivationPolicy:NSApplicationActivationPolicyAccessory]/g" vendor/github.com/wailsapp/wails/v2/internal/frontend/desktop/darwin/AppDelegate.m

      - name: Get Version
        id: get_version
        run: |
          if [ "${{ github.event_name }}" == "push" ]; then
            # Tag push: use the tag name
            echo "VERSION=${{ github.ref_name }}" >> $GITHUB_ENV
          else
            # Manual trigger: use input or auto-increment
            INPUT_VER="${{ github.event.inputs.version }}"
            if [ ! -z "$INPUT_VER" ]; then
              echo "VERSION=$INPUT_VER" >> $GITHUB_ENV
            else
              # Get the highest version tag by sorting all tags
              LATEST_TAG=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*" | sort -V | tail -n 1)
              if [ -z "$LATEST_TAG" ]; then
                LATEST_TAG="v0.0.0"
              fi
              echo "Found latest tag: $LATEST_TAG"
              VERSION_NO_V=${LATEST_TAG#v}
              IFS='.' read -r -a PARTS <<< "$VERSION_NO_V"
              MAJOR=${PARTS[0]}
              MINOR=${PARTS[1]}
              PATCH=${PARTS[2]}
              # Increment and check if tag exists
              while true; do
                NEW_PATCH=$((PATCH + 1))
                NEW_TAG="v$MAJOR.$MINOR.$NEW_PATCH"
                if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
                  echo "Tag $NEW_TAG already exists, trying next..."
                  PATCH=$NEW_PATCH
                else
                  break
                fi
              done
              echo "Auto-incremented version to $NEW_TAG"
              echo "VERSION=$NEW_TAG" >> $GITHUB_ENV
            fi
          fi

      - name: Build & Pack macOS
        run: |
          build_and_pack() {
            arch=$1
            export GOOS=darwin GOARCH=$arch

            LDFLAGS="-X 'guiforcores/bridge.Version=$VERSION'"
            echo "==> Building macOS $arch with version $VERSION..."
            ~/go/bin/wails build -m -s -trimpath -skipbindings -devtools -tags webkit2_41 -ldflags "$LDFLAGS" -o $APP_NAME.exe

            cd build/bin
            zip -q -r $APP_NAME-darwin-$arch.zip $APP_NAME.app
            cd ../..
          }

          for arch in amd64 arm64; do build_and_pack $arch; done

      - uses: actions/upload-artifact@v4
        with:
          name: macos-builds
          path: build/bin/*.zip

  Release:
    needs: [Build-Windows, Build-macOS]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine Version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "push" ]; then
            echo "TAG_NAME=${{ github.ref_name }}" >> $GITHUB_ENV
            echo "TAG_EXISTS=true" >> $GITHUB_ENV
          else
            INPUT_VER="${{ github.event.inputs.version }}"
            if [ ! -z "$INPUT_VER" ]; then
               echo "TAG_NAME=$INPUT_VER" >> $GITHUB_ENV
               # Check if the manually specified tag already exists
               if git rev-parse "$INPUT_VER" >/dev/null 2>&1; then
                 echo "TAG_EXISTS=true" >> $GITHUB_ENV
               else
                 echo "TAG_EXISTS=false" >> $GITHUB_ENV
               fi
            else
               # Get the highest version tag by sorting all tags
               # This ensures we find the actual latest version, not just the one closest to HEAD
               LATEST_TAG=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*" | sort -V | tail -n 1)
               if [ -z "$LATEST_TAG" ]; then
                 LATEST_TAG="v0.0.0"
               fi
               echo "Found latest tag: $LATEST_TAG"
               
               # Remove v, split by dot
               VERSION_NO_V=${LATEST_TAG#v}
               IFS='.' read -r -a PARTS <<< "$VERSION_NO_V"
               MAJOR=${PARTS[0]}
               MINOR=${PARTS[1]}
               PATCH=${PARTS[2]}
               
               # Increment and check if tag exists, keep incrementing if it does
               while true; do
                 NEW_PATCH=$((PATCH + 1))
                 NEW_TAG="v$MAJOR.$MINOR.$NEW_PATCH"
                 if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
                   echo "Tag $NEW_TAG already exists, trying next..."
                   PATCH=$NEW_PATCH
                 else
                   break
                 fi
               done
               
               echo "Auto-incremented version to $NEW_TAG"
               echo "TAG_NAME=$NEW_TAG" >> $GITHUB_ENV
               echo "TAG_EXISTS=false" >> $GITHUB_ENV
            fi
          fi

      - name: Create and Push Tag
        if: env.TAG_EXISTS == 'false'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ env.TAG_NAME }}" -m "Release ${{ env.TAG_NAME }}"
          git push origin "${{ env.TAG_NAME }}"
          echo "Created and pushed new tag: ${{ env.TAG_NAME }}"

      - uses: actions/download-artifact@v4
        with:
          path: release-assets
      
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.TAG_NAME }}
          name: ${{ env.TAG_NAME }}
          files: release-assets/**/*.zip
          draft: false
          prerelease: false
          body: |
            Release ${{ env.TAG_NAME }}
            Auto-generated release from GitHub Actions.
